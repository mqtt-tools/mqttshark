#!/usr/bin/env python3

# (C) 2023  Roger Light <roger@atchoo.org>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import argparse
import json
import subprocess
import sys

# ============================================================
# CONSTANTS
# ============================================================

ansi_reset = "\u001b[0m"
ansi_error = "\u001b[31;7m"
ansi_red = "\u001b[31m"
ansi_green = "\u001b[32m"
ansi_yellow = "\u001b[33m"
ansi_blue = "\u001b[34m"
ansi_magenta = "\u001b[35m"
ansi_cyan = "\u001b[36m"
ansi_white = "\u001b[37m"
ansi_br_black = "\u001b[90m"
ansi_br_red = "\u001b[91m"
ansi_br_green = "\u001b[92m"
ansi_br_yellow = "\u001b[93m"
ansi_br_blue = "\u001b[94m"
ansi_br_magenta = "\u001b[95m"
ansi_br_cyan = "\u001b[96m"
ansi_br_white = "\u001b[97m"

connack_strings = {
    "0": "accepted",
    "1": "refused: protocol version",
    "2": "refused: identifier rejected",
    "3": "refused: server unavailable",
    "4": "refused: bad username or password",
    "5": "refused: not authorized",
}

reason_code_strings = {
    "0": "success",
    "4": "disconnect with will message",
    "16": "no matching subscribers",
    "17": "no subscription existed",
    "24": "continue authentication",
    "25": "reauthenticate",
    "128": "unspecified",
    "129": "malformed packet",
    "130": "protocol error",
    "131": "implementation specific",
    "132": "unsupported protocol version",
    "133": "clientid not valid",
    "134": "bad username or password",
    "135": "not authorized",
    "136": "server unavailable",
    "137": "server busy",
    "138": "banned",
    "139": "server shutting down",
    "140": "bad authentication method",
    "141": "keep alive timeout",
    "142": "session taken over",
    "143": "topic filter invalid",
    "144": "topic name invalid",
    "145": "packet id in use",
    "146": "packet id not found",
    "147": "receive maximum exceeded",
    "148": "topic alias invalid",
    "149": "packet too large",
    "150": "message rate too high",
    "151": "quota exceeded",
    "152": "administrative action",
    "153": "payload format invalid",
    "154": "retain not supported",
    "155": "qos not supported",
    "156": "use another server",
    "157": "server moved",
    "158": "shared subscriptions not supported",
    "159": "connection rate exceeded",
    "160": "maximum connection time",
    "161": "subscription identifiers not supported",
    "162": "wildcard subscriptions not supported",
}

all_props = {
   "0x01": ("payload-format-indicator", "num"),
   "0x02": ("message-expiry-interval", "num"),
   "0x03": ("content-type", "string"),
   "0x08": ("response-topic", "string"),
   "0x09": ("correlation-data", "string"),
   "0x0b": ("subscription-identifier", "num"),
   "0x11": ("session-expiry-interval", "num"),
   "0x12": ("assigned-client-identifier", "string"),
   "0x13": ("server-keep-alive", "num"),
   "0x15": ("authentication-method", "string"),
   "0x16": ("authentication-data", "string"),
   "0x17": ("request-problem-information", "num"),
   "0x18": ("will-delay-interval", "num"),
   "0x19": ("request-response-information", "num"),
   "0x1a": ("response-information", "string"),
   "0x1c": ("server-reference", "string"),
   "0x1f": ("reason-string", "string"),
   "0x21": ("receive-maximum", "num"),
   "0x22": ("topic-alias-maximum", "num"),
   "0x23": ("topic-alias", "num"),
   "0x24": ("maximum-qos", "num"),
   "0x25": ("retain-available", "num"),
   "0x26": ("user-property", "stringpair"),
   "0x27": ("maximum-packet-size", "num"),
   "0x28": ("wildcard-subscription-available", "num"),
   "0x29": ("subscription-identifier-available", "num"),
   "0x2a": ("shared-subscription-available", "num"),
}

origin_b = f"{ansi_green}B{ansi_reset}"
origin_c = f"{ansi_magenta}C{ansi_reset}"
errstr = f"{ansi_error}?{ansi_reset}"

# ============================================================
# OUTPUT COLOURS
# ============================================================
topic_colour = ansi_br_yellow
payload_colour = ansi_br_blue
property_colour = ansi_br_blue
clientid_colour = ansi_br_cyan
keepalive_colour = ansi_br_cyan
cleansession_colour = ansi_br_cyan
protover_colour = ansi_br_cyan
rc_colour = ansi_br_cyan
mid_colour = ansi_br_cyan
qos_colour = ansi_br_cyan
username_colour = ansi_br_cyan
password_colour = ansi_br_cyan
retain_colour = ansi_br_cyan
dup_colour = ansi_br_cyan
sub_opt_colour = ansi_br_cyan
rc_colour = ansi_br_cyan

CONNECT_colour = ansi_yellow
WILL_colour = ansi_br_blue
PUBLISH0_colour = ansi_green
PUBLISH1_colour = ansi_br_green
PUBLISH2_colour = ansi_cyan
SUBSCRIBE_colour = ansi_br_yellow
UNSUBSCRIBE_colour = ansi_magenta
PING_colour = ansi_br_black
DISCONNECT_colour = ansi_blue
AUTH_colour = ansi_br_magenta

# ============================================================
# GLOBAL VARS
# ============================================================

# ANSI colour codes
all_colours = [31, 32, 33, 34, 35, 36, 37, 90, 91, 92, 93, 94, 95, 96, 97]

# Mapping variable to keep track of whether a src port is a client/broker
client_mapping = {}

# Mapping variable to keep track of what MQTT version a client is using
client_versions = {}

# Mapping variable to keep consistent colours for sessions
session_ports = {}

# String that the current packet timestamp is written to before being printed.
# This is used to allow futher lines to print with the correct offset.
timestr = ""

# Timestamp of the first packet received.
epoch = -1

# ============================================================
# Helper functions
# ============================================================

def next_colour():
    """Rotate ansi colour codes for client sessions"""
    c = all_colours.pop(0)
    all_colours.append(c)
    return c


def print_timestamp(packet):
    """Print the packet timestamp. If the packet is malformed, use error colour."""
    global epoch
    global timestr

    ts = packet['timestamp']

    if epoch == -1:
        epoch = int(ts)
        ts = 0
    else:
        ts = int(ts) - epoch

    try:
        ws_malformed = packet['layers']['_ws_malformed']
        malformed = True
    except KeyError:
        malformed = False

    timestr = "%.5f" % (ts/1000)
    if malformed:
        print(f"{ansi_error}{timestr}{ansi_reset}", end="")
    else:
        print(f"{timestr}", end="")


def print_offset():
    """Print sufficient spaces to allow the correct offset on follow up lines."""
    global timestr
    print(" "*(len(timestr)+1+5+2+5+1+2+1+11), end="")


def print_properties(args, mqtt):
    """Print properties for a packet."""
    if args.no_properties:
        return
    try:
        prop_ids = mqtt['mqtt_mqtt_property_id']
        if not isinstance(prop_ids, list):
            prop_ids = [prop_ids]
    except KeyError:
        return

    try:
        prop_keys = mqtt['mqtt_mqtt_prop_key']
        if not isinstance(prop_keys, list):
            prop_keys = [prop_keys]
    except KeyError:
        prop_keys = None

    try:
        prop_values = mqtt['mqtt_mqtt_prop_value']
        if not isinstance(prop_values, list):
            prop_values = [prop_values]
    except KeyError:
        prop_values = None

    try:
        prop_strings = mqtt['mqtt_mqtt_prop_string']
        if not isinstance(prop_strings, list):
            prop_strings = [prop_strings]
    except KeyError:
        prop_strings = None

    try:
        prop_numbers = mqtt['mqtt_mqtt_prop_number']
        if not isinstance(prop_numbers, list):
            prop_numbers = [prop_numbers]
    except KeyError:
        prop_numbers = None

    for prop_id in prop_ids:
        print_offset()
        try:
            (name, prop_type) = all_props[prop_id]
            key = None
            if prop_type == "num":
                try:
                    value = prop_numbers.pop(0)
                except AttributeError:
                    value = errstr
            elif prop_type == "string":
                try:
                    value = prop_strings.pop(0)
                except AttributeError:
                    value = errstr
            elif prop_type == "stringpair":
                try:
                    key = prop_keys.pop(0)
                except AttributeError:
                    key = errstr
                try:
                    value = prop_values.pop(0)
                except AttributeError:
                    value = errstr
            if key is None:
                print(f"{name} {property_colour}{value}{ansi_reset}")
            else:
                print(f"{name} {property_colour}{key}{ansi_reset}={property_colour}{value}{ansi_reset}")
        except KeyError:
            print(f"{errstr} %s" % prop_id)


def print_mid(mqtt):
    try:
        mid = mqtt['mqtt_mqtt_msgid']
    except KeyError:
        mid = errstr

    print(f"mid={mid_colour}{mid}{ansi_reset}  ", end="")


def print_pub_reason_code(mqtt, name):
    try:
        rc = mqtt[f'mqtt_mqtt_{name.strip().lower()}_reason_code']
        try:
            rc_str = reason_code_strings[rc]
        except KeyError:
            rc_str = "?????"
        print(f"rc={rc_colour}{rc}{ansi_reset} ({rc_str}) ", end="")
    except KeyError:
        pass


def print_session_ports(packet):
    srcport = packet['layers']['tcp']['tcp_tcp_srcport']
    dstport = packet['layers']['tcp']['tcp_tcp_dstport']

    key = "%5s-â–º%-5s" % (srcport, dstport)
    try:
        print(session_ports[key], end="")
    except KeyError:
        colour = next_colour()

        s1 = " \u001b[%dm%5s\u001b[0m-â–º\u001b[%dm%-5s\u001b[0m" % (colour, srcport, colour, dstport)
        session_ports[key] = s1
        print(s1, end="")

        key2 = "%5s-â–º%-5s" % (dstport, srcport)
        s2 = " \u001b[%dm%5s\u001b[0m-â–º\u001b[%dm%-5s\u001b[0m" % (colour, dstport, colour, srcport)
        session_ports[key2] = s2


def set_client_mapping(packet):
    src = "%s:%s" % (decode_ip_peer(packet, 'src'), packet['layers']['tcp']['tcp_tcp_srcport'])
    dst = "%s:%s" % (decode_ip_peer(packet, 'dst'), packet['layers']['tcp']['tcp_tcp_dstport'])
    try:
        c = client_mapping[src]
    except KeyError:
        client_mapping[src] = "C"
    try:
        c = client_mapping[dst]
    except KeyError:
        client_mapping[dst] = "B"


def set_client_version(packet, ver):
    src = "%s:%s" % (decode_ip_peer(packet, 'src'), packet['layers']['tcp']['tcp_tcp_srcport'])
    dst = "%s:%s" % (decode_ip_peer(packet, 'dst'), packet['layers']['tcp']['tcp_tcp_dstport'])
    client_versions[src] = ver
    client_versions[dst] = ver


def get_client_version(packet):
    src = "%s:%s" % (decode_ip_peer(packet, 'src'), packet['layers']['tcp']['tcp_tcp_srcport'])
    try:
        return client_versions[src]
    except KeyError:
        return 4


def check_client_mapping(packet):
    src = "%s:%s" % (decode_ip_peer(packet, 'src'), packet['layers']['tcp']['tcp_tcp_srcport'])
    try:
        c = client_mapping[src]
        return c
    except KeyError:
        return "?"


def print_origin(packet, expected=None):
    r = check_client_mapping(packet)
    if expected is not None:
        if r == expected:
            print("  ", end="")
        else:
            print(f" {ansi_error}{r}{ansi_reset}", end="")
    else:
        print(f" {r}", end="")


def decode_ip_peer(packet, peer_type):
    assert peer_type in ['src', 'dst'], f'Peer kind invalid: {peer_type}'
    if 'ip' in packet['layers']:
        return packet['layers']['ip'][f'ip_ip_{peer_type}']
    elif 'ipv6' in packet['layers']:
        return packet['layers']['ipv6'][f'ipv6_ipv6_{peer_type}']
    else:
        raise ValueError(f'No "ip" or "ipv6" in packet layer')


def decode_mqtt_payload(payload):
    """
    Gracefully attempt to decode MQTT message payload from UTF-8.
    If that fails, return the original data, which is a hexlified string.
    """
    try:
        return bytearray.fromhex(payload.replace(":", "")).decode("utf-8")
    except:
        return payload



# ============================================================
# Packet printing functions
# ============================================================

def print_malformed(args, packet, mqtt):
    """Called if a very malformed packet is received"""
    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "")
    print(f" {ansi_error}????????{ansi_reset}")


def print_reserved(args, packet, mqtt):
    """Print RESERVED packet"""
    if "RESERVED" in args.suppress or (len(args.pick) > 0 and "RESERVED" not in args.pick):
        return

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "")
    print(f" {ansi_error}RESERVED{ansi_reset}    rl={mqtt['mqtt_mqtt_len']} {mqtt['mqtt_mqtt_hdrflags']}")
    print_properties(args, mqtt)


def print_will(args, mqtt):
    global timestr
    try:
        flag = mqtt['mqtt_mqtt_conflag_willflag']
    except KeyError:
        return
    if flag == False:
        return

    try:
        topic = mqtt['mqtt_mqtt_willtopic']
        if len(topic) > args.truncate_topic:
            topic = topic[:args.truncate_topic] + "â€¦"
    except KeyError:
        topic = errstr

    try:
        qos = mqtt['mqtt_mqtt_conflag_qos']
    except KeyError:
        qos = errstr

    try:
        payload = mqtt['mqtt_mqtt_willmsg_text']
        if len(payload) > args.truncate_payload:
            payload = payload[:args.truncate_payload] + "â€¦"
    except KeyError:
        payload = errstr

    print(" "*(len(timestr)+1+5+2+5+1+2), end="")
    print(f"{WILL_colour}WILL{ansi_reset}        ", end="")
    print(f"qos={qos_colour}{qos}{ansi_reset}", end="")
    print(f'  topic="{topic_colour}{topic}{ansi_reset}"', end="")
    print(f'  payload="{payload_colour}{payload}{ansi_reset}"', end="")
    print("")
    #print(mqtt['mqtt_mqtt_will_properties'])


def print_connect(args, packet, mqtt):
    """Print CONNECT packet"""
    if "CONNECT" in args.suppress or (len(args.pick) > 0 and "CONNECT" not in args.pick):
        return

    try:
        protoname = mqtt['mqtt_mqtt_protoname']
    except KeyError:
        print_malformed(args, packet, mqtt)
        return

    try:
        protover = mqtt['mqtt_mqtt_ver']
    except KeyError:
        print_malformed(args, packet, mqtt)
        return
    set_client_version(packet, int(protover))

    try:
        username = mqtt['mqtt_mqtt_username']
    except KeyError:
        username = ""
    try:
        password = mqtt['mqtt_mqtt_passwd']
    except KeyError:
        password = ""

    try:
        cleansession = mqtt['mqtt_mqtt_conflag_cleansess']
    except KeyError:
        cleansession = errstr
    try:
        keepalive = mqtt['mqtt_mqtt_kalive']
    except KeyError:
        keepalive = errstr

    try:
        clientid = mqtt['mqtt_mqtt_clientid']
        if len(clientid) > args.truncate_clientid:
            clientid = clientid[:args.truncate_clientid] + "â€¦"
    except KeyError:
        clientid = errstr

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "C")
    print(f' {CONNECT_colour}CONNECT{ansi_reset}     ', end="")
    print(f'clientid="{clientid_colour}{clientid}{ansi_reset}"  ', end="")
    print(f'keepalive={keepalive_colour}{keepalive}{ansi_reset}  ', end="")
    print(f'cleansession={cleansession_colour}{cleansession}{ansi_reset}  ', end="")
    print(f'protover={protover_colour}{protover}{ansi_reset}')

    if username != "" or password != "":
        print_offset()
        print(f'username="{username_colour}{username}{ansi_reset}" ', end="")
        print(f'password="{password_colour}{password}{ansi_reset}"')
    print_properties(args, mqtt)
    print_will(args, mqtt)


def print_connack(args, packet, mqtt):
    """Print CONNACK packet"""
    if "CONNACK" in args.suppress or "ACK" in args.suppress or (len(args.pick) > 0 and "CONNECT" not in args.pick):
        return

    try:
        rc = mqtt['mqtt_mqtt_connack_reason_code']
        rc_str = reason_code_strings[rc]
    except KeyError:
        try:
            rc = mqtt['mqtt_mqtt_conack_val']
            rc_str = connack_strings[rc]
        except KeyError:
            rc = errstr
            rc_str = errstr
    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "B")
    print(f" {CONNECT_colour}CONNACK{ansi_reset}", end="")
    print(f"     rc={rc_colour}{rc}{ansi_reset} ({rc_str})")
    print_properties(args, mqtt)


def print_publish(args, packet, mqtt):
    """Print PUBLISH packet"""
    if "PUBLISH" in args.suppress or (len(args.pick) > 0 and "PUBLISH" not in args.pick):
        return

    try:
        payload = decode_mqtt_payload(mqtt['mqtt_mqtt_msg'])
        if len(payload) > args.truncate_payload:
            payload = payload[:args.truncate_payload] + "â€¦"
    except KeyError:
        payload = errstr

    try:
        qos = mqtt['mqtt_mqtt_qos']
        if qos == "0":
            publish_colour = PUBLISH0_colour
        elif qos == "1":
            publish_colour = PUBLISH1_colour
        elif qos == "2":
            publish_colour = PUBLISH2_colour
        else:
            publish_colour = ansi_error
    except KeyError:
        qos = errstr

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet)
    print(f" {publish_colour}PUBLISH({qos}){ansi_reset}  ", end="")
    if qos != "0":
        print_mid(mqtt)

    try:
        if mqtt['mqtt_mqtt_retain']:
            retain = "1"
        else:
            retain = "0"
    except KeyError:
        retain = errstr
    print(f"retain={retain_colour}{retain}{ansi_reset}", end="")

    try:
        if mqtt['mqtt_mqtt_dupflag']:
            print(f"  {dup_colour}dup{ansi_reset}", end="")
    except KeyError:
        pass

    try:
        topic = mqtt["mqtt_mqtt_topic"]
        if len(topic) > args.truncate_topic:
            topic = topic[:args.truncate_topic] + "â€¦"
    except KeyError:
        topic = errstr

    print(f'  topic="{topic_colour}{topic}{ansi_reset}"', end="")
    print(f'  payload="{payload_colour}{payload}{ansi_reset}"')
    print_properties(args, mqtt)


def print_simple(args, name, colour, packet, mqtt):
    """Print PUBACK/PUBREC/PUBREL/PUBCOMP packet"""
    if "ACK" in args.suppress or "QOS-FLOW" in args.suppress:
        return

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet)
    print(f" {colour}{name}{ansi_reset}     ", end="")
    print_mid(mqtt)
    print_pub_reason_code(mqtt, name)
    print("")
    print_properties(args, mqtt)


def print_sub_options(options_str):
    if options_str == errstr:
        print(errstr, end="")
        return

    options = int(options_str, 16)
    qos = options & 0x03

    no_local = options & 0x04
    retain_as_published = options & 0x08
    retain_handling = (options & 0x30) >> 4
    reserved = (options & 0xC0)

    if qos == 3:
        colour = ansi_error
    else:
        colour = qos_colour
    print(f'qos={colour}{qos}{ansi_reset}', end="")

    if no_local:
        print(f'  {sub_opt_colour}no-local{ansi_reset}', end="")
    if retain_as_published:
        print(f'  {sub_opt_colour}retain-as-published{ansi_reset}', end="")
    if retain_handling == 1:
        print(f'  retain-handling={sub_opt_colour}new{ansi_reset}', end="")
    elif retain_handling == 2:
        print(f'  retain-handling={sub_opt_colour}never{ansi_reset}', end="")
    elif retain_handling == 3:
        print(f'  retain-handling={sub_opt_colour}error{ansi_reset}', end="")
    if reserved:
        print(f'  reserved={ansi_error}{reserved}{ansi_reset}', end="")


def print_subscribe(args, packet, mqtt):
    """Print SUBSCRIBE packet"""
    if "SUBSCRIBE" in args.suppress or (len(args.pick) > 0 and "SUBSCRIBE" not in args.pick):
        return

    try:
        topic = mqtt['mqtt_mqtt_topic']
    except KeyError:
        topic = errstr

    try:
        qos = mqtt['mqtt_mqtt_subscription_options']
    except KeyError:
        try:
            qos = mqtt['mqtt_mqtt_sub_qos']
        except KeyError:
            qos = errstr

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "C")
    print(f" {SUBSCRIBE_colour}SUBSCRIBE{ansi_reset}   ", end="")
    print_mid(mqtt)

    if not isinstance(topic, list):
        if len(topic) > args.truncate_topic:
            topic = topic[:args.truncate_topic] + "â€¦"
        if not isinstance(qos, list):
            print_sub_options(qos)
        else:
            print_sub_options(errstr)
        print(f'  topic="{topic_colour}{topic}{ansi_reset}"')
    else:
        print("")
        for i in range(0, len(topic)):
            print_offset()
            if len(topic[i]) > args.truncate_topic:
                topic[i] = topic[i][:args.truncate_topic] + "â€¦"
            print_sub_options(qos[i])
            print(f'  topic="{topic_colour}{topic[i]}{ansi_reset}"')
    print_properties(args, mqtt)


def print_suback(args, packet, mqtt):
    """Print SUBACK packet"""
    if "SUBACK" in args.suppress or "ACK" in args.suppress or (len(args.pick) > 0 and "SUBSCRIBE" not in args.pick):
        return

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "B")
    print(f" {SUBSCRIBE_colour}SUBACK{ansi_reset}      ", end="")
    print_mid(mqtt)
    try:
        reason_code = mqtt['mqtt_mqtt_suback_reason_code']
    except KeyError:
        try:
            reason_code = mqtt['mqtt_mqtt_suback_qos']
        except KeyError:
            reason_code = errstr

    if not isinstance(reason_code, list):
        reason_code = [reason_code]
    if len(reason_code) > 0:
        print(f"rc={rc_colour}{reason_code[0]}{ansi_reset}", end="")
        if reason_code[0] == errstr or int(reason_code[0]) > 2:
            try:
                rc_str = reason_code_strings[reason_code[0]]
            except KeyError:
                rc_str = errstr
            print(f" ({rc_str})", end="")

        reason_code.pop(0)
        for rc in reason_code:
            print(f", {rc_colour}{rc}{ansi_reset}", end="")
            if rc == errstr or int(rc) > 2:
                try:
                    rc_str = reason_code_strings[rc]
                except KeyError:
                    rc_str = errstr
                print(f" ({rc_str})", end="")
        print("")
    else:
        print(f"rc={errstr}")
    print_properties(args, mqtt)


def print_unsubscribe(args, packet, mqtt):
    """Print UNSUBSCRIBE packet"""
    if "UNSUBSCRIBE" in args.suppress or (len(args.pick) > 0 and "UNSUBSCRIBE" not in args.pick):
        return

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "C")
    print(f" {UNSUBSCRIBE_colour}UNSUBSCRIBE{ansi_reset} ", end="")
    print_mid(mqtt)
    try:
        topic = mqtt['mqtt_mqtt_topic']
    except KeyError:
        topic = errstr

    if not isinstance(topic, list):
        if len(topic) > args.truncate_topic:
            topic = topic[:args.truncate_topic] + "â€¦"
        print(f'topic="{topic_colour}{topic}{ansi_reset}"')
    else:
        topic = [topic]
        for i in range(0, len(topic)):
            print_offset()
            if len(topic[i]) > args.truncate_topic:
                topic[i] = topic[i][:args.truncate_topic] + "â€¦"
            print(f'topic="{topic_colour}{topic[i]}{ansi_reset}"')
    print_properties(args, mqtt)


def print_unsuback(args, packet, mqtt):
    """Print UNSUBACK packet"""
    if "UNSUBACK" in args.suppress or "ACK" in args.suppress or (len(args.pick) > 0 and "UNSUBSCRIBE" not in args.pick):
        return

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "B")
    print(f" {UNSUBSCRIBE_colour}UNSUBACK{ansi_reset}    ", end="")
    print_mid(mqtt)

    try:
        reason_code = mqtt['mqtt_mqtt_suback_qos']
        if not isinstance(reason_code, list):
            reason_code = [reason_code]
        if len(reason_code) > 0:
            print(f"rc={rc_colour}{reason_code[0]}{ansi_reset}", end="")
            if reason_code[0] == errstr or int(reason_code[0]) != 0:
                rc_str = reason_code_strings[reason_code[0]]
                print(f" ({rc_str})", end="")

            reason_code.pop(0)
            for rc in reason_code:
                print(f",{rc_colour}{rc}{ansi_reset}", end="")
                if rc == errstr or int(rc) != 0:
                    rc_str = reason_code_strings[rc]
                    print(f" ({rc_str})", end="")
        else:
            print(f"rc={errstr}", end="")
    except KeyError:
        pass
    print("")


    print_properties(args, mqtt)


def print_pingreq(args, packet, mqtt):
    """Print PINGREQ packet"""
    if "PINGREQ" in args.suppress or "PING" in args.suppress or (len(args.pick) > 0 and "PING" not in args.pick):
        return

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "C")
    print(f" {PING_colour}PINGREQ{ansi_reset}", end="")
    if int(mqtt['mqtt_mqtt_len']) == 0 and mqtt['mqtt_mqtt_hdrflags'] == "0xc0":
        print("")
    else:
        print("     rl=%s %s" % (mqtt['mqtt_mqtt_len'], mqtt['mqtt_mqtt_hdrflags']))
    print_properties(args, mqtt)


def print_pingresp(args, packet, mqtt):
    """Print PINGRESP packet"""
    if "PINGRESP" in args.suppress or "PING" in args.suppress or (len(args.pick) > 0 and "PING" not in args.pick):
        return

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet, "B")
    print(f" {PING_colour}PINGRESP{ansi_reset}", end="")
    if int(mqtt['mqtt_mqtt_len']) == 0 and mqtt['mqtt_mqtt_hdrflags'] == "0xd0":
        print("")
    else:
        print("    rl=%s %s" % (mqtt['mqtt_mqtt_len'], mqtt['mqtt_mqtt_hdrflags']))
    print_properties(args, mqtt)


def print_disconnect(args, packet, mqtt):
    """Print DISCONNECT packet"""
    if "DISCONNECT" in args.suppress or (len(args.pick) > 0 and "DISCONNECT" not in args.pick):
        return

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet)
    print(f" {DISCONNECT_colour}DISCONNECT{ansi_reset} ", end="")
    try:
        reason_code = mqtt['mqtt_mqtt_disconnect_reason_code']
        rc_str = reason_code_strings[reason_code]
        print(f" rc={rc_colour}{reason_code}{ansi_reset} ({rc_str})")
    except KeyError:
        print("")
    print_properties(args, mqtt)


def print_auth(args, packet, mqtt):
    """Print AUTH packet"""
    if "AUTH" in args.suppress or (len(args.pick) > 0 and "AUTH" not in args.pick):
        return

    print_timestamp(packet)
    print_session_ports(packet)
    print_origin(packet)
    print(f" {AUTH_colour}AUTH{ansi_reset}        rl={mqtt['mqtt_mqtt_len']}")
    print_properties(args, packet)


# ============================================================
# COMMAND ARGUMENT HANDLING
# ============================================================


class SuppressAction(argparse.Action):
    def __init__(self, option_strings, dest="suppress", nargs=0, default=[], **kwargs):
        super().__init__(option_strings, "suppress", nargs=0, default=[], **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        values = getattr(namespace, self.dest)
        values.append(option_string[5:].upper())
        setattr(namespace, self.dest, values)

class PickAction(argparse.Action):
    def __init__(self, option_strings, dest="pick", nargs=0, default=[], **kwargs):
        super().__init__(option_strings, "pick", nargs=0, default=[], **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        values = getattr(namespace, self.dest)
        values.append(option_string[7:].upper())
        setattr(namespace, self.dest, values)

def get_args():
    parser = argparse.ArgumentParser(
        prog="mqttshark",
        description="Pretty print MQTT traffic from tshark",
        epilog="https://github.com/mqtt-tools/mqttshark"
    )
    parser.add_argument(
        '-i', '--interface', action='store',
        help="network interface, defaults to the first non-loopback"
    )
    parser.add_argument(
        '-p', '--port', action='store', default="1883",
        help="comma separated list of network ports to observe, defaults to 1883. " \
                +"It is possible to choose which protocol to decode by using e.g. '-p 1883:mqtt,8883:mqtts," \
                +"8080:ws,8081:wss'"
    )
    parser.add_argument(
        "-v", "--version", action="version",
        version = f"{parser.prog} version 0.0.1"
    )
    parser.add_argument(
        "--tls-keylog", action="store", type=str, default=None,
        help="path to TLS key log file, for packet decryption. Applies to all TLS ports"
    )
    parser.add_argument(
        "--default-version", action="store", type=int, default=None,
        help="default MQTT protocol version to use, if CONNECT not seen. 3, 4, or 5"
    )

    output_modifier_group = parser.add_argument_group('Output modification', 'Change what information is displayed')
    output_modifier_group_args = [
        ('--no-properties', "don't display MQTT v5.0 properties")
    ]
    for opt,help in output_modifier_group_args:
        output_modifier_group.add_argument(opt, action='store_true', help=help)

    output_modifier_group.add_argument("--truncate-clientid", action="store", default=23, type=int,
        help="Truncate clientids to this number of characters. Defaults to 23.")

    output_modifier_group.add_argument("--truncate-payload", action="store", default=30, type=int,
        help="Truncate payloads to this number of characters. Defaults to 30.")

    output_modifier_group.add_argument("--truncate-topic", action="store", default=30, type=int,
        help="Truncate topics to this number of characters. Defaults to 30.")

    pick_type_group = parser.add_argument_group('Pick command', "Display messages only from the picked groups. Multiple groups may be used.")
    pick_type_args = [
        ("--pick-connect", "display MQTT CONNECT/CONNACK"),
        ("--pick-publish", "display MQTT PUBLISH/PUBACK/PUBREC/PUBREL/PUBCOMP"),
        ("--pick-subscribe", "display MQTT SUBSCRIBE/SUBACK"),
        ("--pick-unsubscribe", "display MQTT UNSUBSCRIBE/UNSUBACK"),
        ("--pick-ping", "display MQTT PINGREQ/PINGRESP"),
        ("--pick-disconnect", "display MQTT DISCONNECT"),
        ("--pick-auth", "display MQTT AUTH"),
        ("--pick-reserved", "display MQTT RESERVED"),
    ]
    for opt,help in pick_type_args:
        pick_type_group.add_argument(opt, action=PickAction, help=help)

    suppression_group = parser.add_argument_group('Packet suppression', "Don't display certain packets")
    suppression_group_args = [
        ('--no-connect', "don't display MQTT CONNECT"),
        ('--no-connack', "don't display MQTT CONNACK"),
        ('--no-publish', "don't display MQTT PUBLISH"),
        ('--no-puback', "don't display MQTT PUBACK"),
        ('--no-pubrec', "don't display MQTT PUBREC"),
        ('--no-pubrel', "don't display MQTT PUBREL"),
        ('--no-pubcomp', "don't display MQTT PUBCOMP"),
        ('--no-subscribe', "don't display MQTT SUBSCRIBE"),
        ('--no-suback', "don't display MQTT SUBACK"),
        ('--no-unsubscribe', "don't display MQTT UNSUBSCRIBE"),
        ('--no-unsuback', "don't display MQTT UNSUBACK"),
        ('--no-pingreq', "don't display MQTT PINGREQ"),
        ('--no-pingresp', "don't display MQTT PINGRESP"),
        ('--no-disconnect', "don't display MQTT DISCONNECT"),
        ('--no-auth', "don't display MQTT AUTH"),
        ('--no-reserved', "don't display MQTT RESERVED"),
        ('--no-ack', "don't display MQTT acknowledge packets (CONNACK, PUBACK, PUBREC, PUBREL, PUBCOMP, SUBACK, UNSUBACK)"),
        ('--no-qos-flow', "don't display MQTT PUBLISH acknowledge packets (PUBACK, PUBREC, PUBREL, PUBCOMP)"),
        ('--no-ping', "don't display MQTT PINGREQ/PINGRESP")
    ]
    for opt,help in suppression_group_args:
        suppression_group.add_argument(opt, action=SuppressAction, help=help)

    return parser.parse_args()

# ============================================================
# WEBSOCKETS PARSING FUNCTIONS
# ============================================================

# -----------------
# Datatypes
# -----------------
def ws_parse_varint(packet, rl, ws_data):
    mult = 1
    varint = 0
    while True:
        rl, b = ws_parse_byte(packet, rl, ws_data)
        if b == errstr:
            return 0, errstr
        varint += (b & 127) * mult
        mult *= 128
        if b & 128 == 0:
            return rl, varint
    return rl, varint


def ws_parse_uint32(packet, rl, ws_data):
    try:
        d = int(ws_data.pop(0) + ws_data.pop(0) + ws_data.pop(0) + ws_data.pop(0), 16)
        return rl-4, d
    except IndexError:
        set_malformed(packet)
        return 0, errstr

def ws_parse_uint16(packet, rl, ws_data):
    try:
        d = int(ws_data.pop(0) + ws_data.pop(0), 16)
        return rl-2, d
    except IndexError:
        set_malformed(packet)
        return 0, errstr

def ws_parse_byte(packet, rl, ws_data):
    try:
        d = int(ws_data.pop(0), 16)
        return rl-1, d
    except IndexError:
        set_malformed(packet)
        return 0, errstr


def ws_parse_string(packet, rl, ws_data):
    s = ""
    try:
        rl, d = ws_parse_uint16(packet, rl, ws_data)
        if d == errstr:
            return 0, s+errstr
        for i in range(0, d):
            s += chr(int(ws_data.pop(0), 16))
        return rl-d, s
    except IndexError:
        set_malformed(packet)
        return 0, s+errstr


def ws_parse_binary(packet, rl, ws_data):
    s = ""
    try:
        rl, d = ws_parse_uint16(packet, rl, ws_data)
        if d == errstr:
            return 0, s+errstr
        for i in range(0, d):
            s += ws_data.pop(0)
        return rl-d, s
    except IndexError:
        set_malformed(packet)
        return 0, s+errstr


def ws_property_add(mqtt, key, value):
    try:
        mqtt[key].append(value)
    except KeyError:
        mqtt[key] = [value]

def ws_property_add_id(mqtt, value):
    value = f"0x{value:02x}"
    ws_property_add(mqtt, 'mqtt_mqtt_property_id', value)

def ws_property_add_number(mqtt, value):
    ws_property_add(mqtt, 'mqtt_mqtt_prop_number', value)

def ws_property_add_string(mqtt, value):
    ws_property_add(mqtt, 'mqtt_mqtt_prop_string', value)

def ws_property_add_string_pair(mqtt, key, value):
    ws_property_add(mqtt, 'mqtt_mqtt_prop_key', key)
    ws_property_add(mqtt, 'mqtt_mqtt_prop_value', value)


def ws_parse_properties(packet, mqtt, rl, ws_data):
    rl, proplen = ws_parse_varint(packet, rl, ws_data)
    if proplen == errstr:
        return 0
    i = 0
    while i < proplen:
        readlen, propid = ws_parse_varint(packet, 0, ws_data)
        if propid == errstr:
            return 0
        i += -1*readlen
        rl -= -1*readlen

        if propid in [1, 23, 25, 36, 37, 40, 41, 42]:
            # byte
            rl, value = ws_parse_byte(packet, rl, ws_data)
            i += 1
            ws_property_add_id(mqtt, propid)
            ws_property_add_number(mqtt, value)
        elif propid in [2, 17, 24, 39]:
            # 4 byte integer
            rl, value = ws_parse_uint32(packet, rl, ws_data)
            i += 4
            ws_property_add_id(mqtt, propid)
            ws_property_add_number(mqtt, value)
        elif propid in [3, 8, 18, 21, 26, 28, 31]:
            # utf-8 string
            ws_property_add_id(mqtt, propid)
            readlen, value = ws_parse_string(packet, 0, ws_data)
            i -= readlen
            rl += readlen
            ws_property_add_string(mqtt, value)
        elif propid in [9, 22]:
            # binary
            readlen, value = ws_parse_binary(packet, 0, ws_data)
            i -= readlen
            rl += readlen
            ws_property_add_id(mqtt, propid)
            ws_property_add_string(mqtt, value)
        elif propid in [11]:
            # varint
            readlen, value = ws_parse_varint(packet, 0, ws_data)
            i -= readlen
            rl += readlen
            ws_property_add_id(mqtt, propid)
            ws_property_add_number(mqtt, value)
        elif propid in [19, 33, 34, 35]:
            # two byte int
            rl, value = ws_parse_uint16(packet, rl, ws_data)
            i += 2
            ws_property_add_id(mqtt, propid)
            ws_property_add_number(mqtt, value)
        elif propid in [38]:
            # utf-8 string pair
            readlen, key = ws_parse_string(packet, 0, ws_data)
            i -= readlen
            rl += readlen
            readlen, value = ws_parse_string(packet, 0, ws_data)
            i -= readlen
            rl += readlen
            ws_property_add_id(mqtt, propid)
            ws_property_add_string_pair(mqtt, key, value)
        else:
            pass

    return rl

# -----------------
# Packet types
# -----------------
def ws_parse_reserved(packet, protover, mqtt, rl, ws_data):
    return rl


def ws_parse_connect(packet, protover, cmd, mqtt, rl, ws_data):
    rl, mqtt['mqtt_mqtt_protoname'] = ws_parse_string(packet, rl, ws_data)
    rl, mqtt['mqtt_mqtt_ver'] = ws_parse_byte(packet, rl, ws_data)
    rl, flags = ws_parse_byte(packet, rl, ws_data)
    mqtt['mqtt_mqtt_conflag_cleansess'] = (flags & 0x02) > 0
    mqtt['mqtt_mqtt_conflag_willflag'] = (flags & 0x04) > 0
    mqtt['mqtt_mqtt_conflag_qos'] = str((flags & 0x18) >> 3)
    mqtt['mqtt_mqtt_conflag_willretain'] = flags & 0x20 > 0
    mqtt['mqtt_mqtt_conflag_passwd'] = flags & 0x40 > 0
    mqtt['mqtt_mqtt_conflag_uname'] = flags & 0x80 > 0
    rl, mqtt['mqtt_mqtt_kalive'] = ws_parse_uint16(packet, rl, ws_data)

    if mqtt['mqtt_mqtt_ver'] == 5:
        rl = ws_parse_properties(packet, mqtt, rl, ws_data)

    rl, mqtt['mqtt_mqtt_clientid'] = ws_parse_string(packet, rl, ws_data)
    if mqtt['mqtt_mqtt_conflag_willflag']:
        # FIXME - needs will specific prop parsing
        rl = ws_parse_properties(packet, mqtt, rl, ws_data)
        rl, mqtt['mqtt_mqtt_willtopic'] = ws_parse_string(packet, rl, ws_data)
        rl, payloadlen = ws_parse_uint16(packet, rl, ws_data)
        if payloadlen == errstr:
            mqtt['mqtt_mqtt_willmsg_text'] = errstr
            return 0

        mqtt['mqtt_mqtt_willmsg_text'] = ""
        for i in range(payloadlen):
            rl, b = ws_parse_byte(packet, rl, ws_data)
            if b == errstr:
                mqtt['mqtt_mqtt_willmsg_text'] += errstr
                return 0
            mqtt['mqtt_mqtt_willmsg_text'] += chr(b)

    if mqtt['mqtt_mqtt_conflag_uname']:
        rl, mqtt['mqtt_mqtt_username'] = ws_parse_string(packet, rl, ws_data)
    if mqtt['mqtt_mqtt_conflag_passwd']:
        rl, mqtt['mqtt_mqtt_passwd'] = ws_parse_string(packet, rl, ws_data)

    return rl


def ws_parse_connack(packet, protover, mqtt, rl, ws_data):
    rl, flags = ws_parse_byte(packet, rl, ws_data)
    mqtt['mqtt_mqtt_conack_val'] = str(flags)

    rl, reason_code = ws_parse_byte(packet, rl, ws_data)
    mqtt['mqtt_mqtt_connack_reason_code'] = str(reason_code)

    if protover == 5:
        rl = ws_parse_properties(packet, mqtt, rl, ws_data)

    return rl


def ws_parse_publish(packet, protover, cmd, mqtt, rl, ws_data):
    dup = (cmd & 0x08)>>3
    qos = (cmd & 0x06)>>1
    retain = (cmd & 0x01)

    mqtt['mqtt_mqtt_qos'] = str(qos)
    mqtt['mqtt_mqtt_retain'] = str(retain)

    rl, topic = ws_parse_string(packet, rl, ws_data)
    mqtt['mqtt_mqtt_topic'] = topic

    if qos > 0:
        rl, mqtt['mqtt_mqtt_msgid'] = ws_parse_uint16(packet, rl, ws_data)

    if protover == 5:
        rl = ws_parse_properties(packet, mqtt, rl, ws_data)

    mqtt['mqtt_mqtt_msg_text'] = ""
    while len(ws_data) > 0:
        rl, b = ws_parse_byte(packet, rl, ws_data)
        if b == errstr:
            mqtt['mqtt_mqtt_msg_text'] += errstr
            return 0
        mqtt['mqtt_mqtt_msg_text'] += chr(b)

    return rl


def ws_parse_simple(packet, protover, mqtt, rl, ws_data):
    rl, mqtt['mqtt_mqtt_msgid'] = ws_parse_uint16(packet, rl, ws_data)
    if protover == 5:
        if rl > 0:
            rl, value = ws_parse_byte(packet, rl, ws_data)
            mqtt['mqtt_mqtt_puback_reason_code'] = str(value)
            if rl > 0:
                rl = ws_parse_properties(packet, mqtt, rl, ws_data)
    return rl


def ws_parse_subscribe(packet, protover, mqtt, rl, ws_data):
    rl, mqtt['mqtt_mqtt_msgid'] = ws_parse_uint16(packet, rl, ws_data)

    if protover == 5:
        rl = ws_parse_properties(packet, mqtt, rl, ws_data)

    topics = []
    qoss = []
    while rl > 0:
        rl, topic = ws_parse_string(packet, rl, ws_data)
        rl, qos = ws_parse_byte(packet, rl, ws_data)
        topics.append(topic)
        qoss.append(qos)

    if len(topics) == 1:
        mqtt['mqtt_mqtt_topic'] = topics[0]
        mqtt['mqtt_mqtt_sub_qos'] = qoss[0]
    else:
        mqtt['mqtt_mqtt_topic'] = topics
        mqtt['mqtt_mqtt_sub_qos'] = qoss

    return rl


def ws_parse_suback(packet, protover, mqtt, rl, ws_data):
    rl, mqtt['mqtt_mqtt_msgid'] = ws_parse_uint16(packet, rl, ws_data)

    rl = ws_parse_properties(packet, mqtt, rl, ws_data)
    if rl == 1:
        rl, b = ws_parse_byte(packet, rl, ws_data)
        mqtt['mqtt_mqtt_suback_qos'] = str(b)
    else:
        mqtt['mqtt_mqtt_suback_qos'] = []
        for i in range(0, rl):
            rl, b = ws_parse_byte(packet, rl, ws_data)
            mqtt['mqtt_mqtt_suback_qos'].append(str(b))

    return 0


def ws_parse_unsubscribe(packet, protover, mqtt, rl, ws_data):
    rl, mqtt['mqtt_mqtt_msgid'] = ws_parse_uint16(packet, rl, ws_data)

    if protover == 5:
        rl = ws_parse_properties(packet, mqtt, rl, ws_data)

    topics = []
    while rl > 0:
        rl, topic = ws_parse_string(packet, rl, ws_data)
        topics.append(topic)

    if len(topics) == 1:
        mqtt['mqtt_mqtt_topic'] = topics[0]
    else:
        mqtt['mqtt_mqtt_topic'] = topics
    return rl


def ws_parse_unsuback(packet, protover, mqtt, rl, ws_data):
    rl, mqtt['mqtt_mqtt_msgid'] = ws_parse_uint16(packet, rl, ws_data)

    if protover == 5:
        rl = ws_parse_properties(packet, mqtt, rl, ws_data)

    if rl == 1:
        rl, b = ws_parse_byte(packet, rl, ws_data)
        mqtt['mqtt_mqtt_suback_qos'] = str(b)
    else:
        mqtt['mqtt_mqtt_suback_qos'] = []
        for i in range(0, rl):
            rl, b = ws_parse_byte(packet, rl, ws_data)
            mqtt['mqtt_mqtt_suback_qos'].append(str(b))
    return rl


def ws_parse_pingreq(packet, protover, mqtt, rl, ws_data):
    return rl


def ws_parse_pingresp(packet, protover, mqtt, rl, ws_data):
    return rl


def ws_parse_disconnect(packet, protover, mqtt, rl, ws_data):
    if protover == 5:
        rl, reason_code = ws_parse_byte(packet, rl, ws_data)
        mqtt['mqtt_mqtt_disconnect_reason_code'] = str(reason_code)
        rl = ws_parse_properties(packet, mqtt, rl, ws_data)

    return rl


def ws_parse_auth(packet, protover, mqtt, rl, ws_data):
    return rl

# -----------------
# Main WS functions
# -----------------

def set_malformed(packet):
    print(",.....")
    raise ValueError("")
    packet['layers']['_ws_malformed'] = {}

def ws_parse_packet(packet, ws_data):
    mqtt = {}
    b = ws_data.pop(0)
    mqtt['mqtt_mqtt_hdrflags'] = f"0x{b}"
    cmd_full = int(b, 16)
    cmd = cmd_full & 0xF0
    mqtt['mqtt_mqtt_msgtype'] = str(cmd)
    _, rl = ws_parse_varint(packet, 0, ws_data)
    mqtt['mqtt_mqtt_len'] = str(rl)
    if rl == errstr:
        return mqtt

    protover = get_client_version(packet)

    if cmd == 0x00:
        rl = ws_parse_reserved(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0x10:
        rl = ws_parse_connect(packet, protover, cmd_full, mqtt, rl, ws_data)
    elif cmd == 0x20:
        rl = ws_parse_connack(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0x30:
        rl = ws_parse_publish(packet, protover, cmd_full, mqtt, rl, ws_data)
    elif cmd == 0x40:
        rl = ws_parse_simple(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0x50:
        rl = ws_parse_simple(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0x60:
        rl = ws_parse_simple(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0x70:
        rl = ws_parse_simple(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0x80:
        rl = ws_parse_subscribe(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0x90:
        rl = ws_parse_suback(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0xA0:
        rl = ws_parse_unsubscribe(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0xB0:
        rl = ws_parse_unsuback(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0xC0:
        rl = ws_parse_pingreq(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0xD0:
        rl = ws_parse_pingresp(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0xE0:
        rl = ws_parse_disconnect(packet, protover, mqtt, rl, ws_data)
    elif cmd == 0xF0:
        rl = ws_parse_auth(packet, protover, mqtt, rl, ws_data)

    if rl > 0:
        set_malformed(packet)
    return mqtt

def process_websockets(packet):
    try:
        websockets = packet['layers']['websocket']
        data = packet['layers']['data']
        if not isinstance(data, list):
            data = [data]
    except KeyError:
        return

    mqtt = []
    for d in data:
        ws_data = d['data_data_data'].split(":")
        mqtt.append(ws_parse_packet(packet, ws_data))

    #"mqtt_mqtt_hdr_reserved": "0",
    if len(mqtt) == 1:
        packet['layers']['mqtt'] = mqtt[0]
    else:
        packet['layers']['mqtt'] = mqtt


# ============================================================
# MAIN FUNCTIONS
# ============================================================

def process_packets(tshark, args):
    while True:
        line = tshark.stdout.readline()
        if tshark.returncode is not None:
            sys.exit(tshark.returncode)

        packet = json.loads(line)

        process_websockets(packet)

        try:
            mqttlist = packet['layers']['mqtt']
        except KeyError:
            continue

        if not isinstance(mqttlist, list):
            mqttlist = [mqttlist]

        for mqtt in mqttlist:
            try:
                hdr = int(mqtt['mqtt_mqtt_hdrflags'], 16)
                cmd = hdr & 0xF0
            except KeyError:
                print_malformed(args, packet, mqtt)
                continue

            if cmd == 0x00:
                print_reserved(args, packet, mqtt)
            elif cmd == 0x10:
                set_client_mapping(packet)
                print_connect(args, packet, mqtt)
            elif cmd == 0x20:
                print_connack(args, packet, mqtt)
            elif cmd == 0x30:
                print_publish(args, packet, mqtt)
            elif cmd == 0x40:
                if "PUBACK" not in args.suppress:
                    print_simple(args, "PUBACK ", ansi_br_green, packet, mqtt)
            elif cmd == 0x50:
                if "PUBREC" not in args.suppress:
                    print_simple(args, "PUBREC ", ansi_cyan, packet, mqtt)
            elif cmd == 0x60:
                if "PUBREL" not in args.suppress:
                    print_simple(args, "PUBREL ", ansi_cyan, packet, mqtt)
            elif cmd == 0x70:
                if "PUBCOMP" not in args.suppress:
                    print_simple(args, "PUBCOMP", ansi_cyan, packet, mqtt)
            elif cmd == 0x80:
                print_subscribe(args, packet, mqtt)
            elif cmd == 0x90:
                print_suback(args, packet, mqtt)
            elif cmd == 0xA0:
                print_unsubscribe(args, packet, mqtt)
            elif cmd == 0xB0:
                print_unsuback(args, packet, mqtt)
            elif cmd == 0xC0:
                print_pingreq(args, packet, mqtt)
            elif cmd == 0xD0:
                print_pingresp(args, packet, mqtt)
            elif cmd == 0xE0:
                print_disconnect(args, packet, mqtt)
            elif cmd == 0xF0:
                print_auth(args, packet, mqtt)


def main():
    args = get_args()

    cmd = ["tshark", "-T", "ek", "-q"]
    if args.interface is not None:
        cmd += ["-i", args.interface]

    ports = []
    ports_pre_split = args.port.split(",")
    for i in range(len(ports_pre_split)):
        try:
            port,decode = ports_pre_split[i].split(":")
        except ValueError:
            port = ports_pre_split[i]
            decode = "mqtt"
        if decode != "mqtt" and decode != "mqtts" and decode != "ws" and decode != "wss":
            print(f"Error: Protocol decode must be one of mqtt, mqtts, ws, wss.")
            exit(1)

        ports.append((port, decode))

    p = f"tcp port {ports[0][0]}"
    for i in range(1, len(ports)):
        p += f" or tcp port {ports[i][0]}"
    cmd += ["-f", p]

    if args.tls_keylog is not None:
        cmd += ['-o', f'tls.keylog_file:{args.tls_keylog}']

    for port,decode in ports:
        if decode == "mqtt":
            cmd += ["-d", f"tcp.port=={port},mqtt"]
        elif decode == "mqtts":
            if args.tls_keylog is None:
                print("Error: Trying to use mqtts without --tls-keylog will not work.")
                exit(1)
            cmd += ["-d", f"tcp.port=={port},tls", "-d", f"tls.port=={port},mqtt"]
        elif decode == "ws":
            cmd += ["-d", f"tcp.port=={port},http"]
        elif decode == "wss":
            if args.tls_keylog is None:
                print("Error: Trying to use wss without --tls-keylog will not work.")
                exit(1)
            cmd += ["-d", f"tcp.port=={port},tls", "-d", f"tls.port=={port},http"]

    if args.default_version is not None:
        if args.default_version == 3:
            ver = "MQTT v3.1"
        elif args.default_version == 4:
            ver = "MQTT v3.1.1"
        elif args.default_version == 5:
            ver = "MQTT v5.0"
        else:
            raise ValueError("--default-version must be 3, 4, or 5")
        cmd += ['-o', f'mqtt.default_version:{ver}']

    tshark = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    process_packets(tshark, args)

main()
